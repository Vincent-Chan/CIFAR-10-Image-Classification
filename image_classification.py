# -*- coding: utf-8 -*-
"""image_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15oSmwzNcHnHXlrtRbgXaEwUiS6QaSU8e
"""

# Import the necessary libraries and modules

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.layers import Input, Conv2D, Dense, Flatten, Dropout
from tensorflow.keras.layers import GlobalMaxPooling2D, MaxPooling2D
from tensorflow.keras.layers import BatchNormalization
from tensorflow.keras.models import Model

# Check the version of tensorflow

print(tf.__version__)

# Load the CIFAR-10 dataset using tensorflow's keras API
cifar10 = tf.keras.datasets.cifar10

# Separate it to train dataset and test dataset
(x_train, y_train), (x_test, y_test) = cifar10.load_data()

print("Shape of x_train:", x_train.shape)
print("Shape of y_train:", y_train.shape)
print("Shape of x_test:", x_test.shape)
print("Shape of y_test:", y_test.shape)

# Let's reduce the pixel values by dividng by 255
x_train, x_test = x_train / 255.0, x_test / 255.0

# Also, let's flatten the labels
y_train, y_test = y_train.flatten(), y_test.flatten()

# Let's visualize the x_train dataset
fig, ax = plt.subplots(5, 5)
k = 0

for i in range(5):
	for j in range(5):
		ax[i][j].imshow(x_train[k], aspect='auto')
		k += 1

plt.show()

# Specifiy how many classes in total
# It should have 10 classes
K = len(set(y_train))

print("number of classes:", K)

# Build the model using the functional API
i = Input(shape=x_train[0].shape)

x = Conv2D(32, (3, 3), activation='relu', padding='same')(i)
x = BatchNormalization()(x)
x = Conv2D(32, (3, 3), activation='relu', padding='same')(x)
x = BatchNormalization()(x)
x = MaxPooling2D((2, 2))(x)

x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
x = BatchNormalization()(x)
x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
x = BatchNormalization()(x)
x = MaxPooling2D((2, 2))(x)

x = Conv2D(128, (3, 3), activation='relu', padding='same')(x)
x = BatchNormalization()(x)
x = Conv2D(128, (3, 3), activation='relu', padding='same')(x)
x = BatchNormalization()(x)
x = MaxPooling2D((2, 2))(x)

x = Flatten()(x)
x = Dropout(0.2)(x)

# Hidden layer
x = Dense(1024, activation='relu')(x)
x = Dropout(0.2)(x)

# Output layer
x = Dense(K, activation='softmax')(x)

model = Model(i, x)

# The summary of the model
model.summary()

# Compile the model
# We use:
# Adam optimizer
# sparse_categorical_crossentropy as the loss function
# accuracy as the metrics

model.compile(optimizer='adam',
			        loss='sparse_categorical_crossentropy',
			        metrics=['accuracy'])

# Train the model for 50 epoches
r = model.fit(x_train, y_train, validation_data = (x_test, y_test), epochs = 50)

# Plot the accuracy

plt.plot(r.history['accuracy'], label='acc', color='red')
plt.plot(r.history['val_accuracy'], label='val_acc', color='green')
plt.legend()

# Map the labels
labels = '''airplane automobile bird cat deer dog frog horse ship truck'''.split()

# Set the image number as 0 by default
# You can change it to any interger you want (range: 0 to 9999)
image_number = 0

# Display the image
plt.imshow(x_test[image_number])

# Load the image in an array
n = np.array(x_test[image_number])

# Reshape it to (1, 32, 32, 3)
p = n.reshape(1, 32, 32, 3)

# Pass in the network for prediction and save the predicted label
predicted_label = labels[model.predict(p).argmax()]

# Load the original label
original_label = labels[y_test[image_number]]

# Display the result
print("Original label is {} and predicted label is {}".format(original_label, predicted_label))

# Save the model
model.save('CIFAR-10_image_classification_model.h5')